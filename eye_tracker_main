#!/usr/bin/env python
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import argparse
import glob
import os
from scipy.spatial.distance import cdist

# import functions
import pupil_detection
import rough_estimation

filelist = []
imglist = []
cimglist = []
center_list = []
# Mat_centers = np.zeros((5, 3), np.float32)      # Zeilen, Spalten
k = 0

for root, dirs, files in os.walk(r'../data/eye_new/right'):     # create filelist of source images
    for file in files:
        if file.endswith('.png'):
            filelist.append(root+'/'+file)

for imagefile in filelist:                                  # load source images ans store in list
    img_load = cv2.imread(imagefile, 0)
    imglist.append(img_load)

    cimg = cv2.cvtColor(img_load, cv2.COLOR_GRAY2BGR)
    cimglist.append(cimg)

height, width = img_load.shape                              # get image size
white_img = np.zeros((1000, 1000, 3), np.uint8)             # create blank image
white_img[:] = (255, 255, 255)

# pupil_detection.houghCircle(cimglist[0])


for img in imglist:

    #center = pupil_detection.center_of_mass(img)
    center = pupil_detection.hough_circle(img)
    #center = rough_estimation.darkest_area(img)

    if center is not None:

        center_list.append(center)

        for i in center_list:
            # draw the center of the circle
            cv2.circle(cimglist[k], (int(i[0]), int(i[1])), 3, (0, 0, 255), 3)

        # cv2.imshow(str(k),cimglist[k])
        for i in center_list:
            cv2.circle(white_img, (int(i[0]), int(i[1])), 1, (0, 0, 255), 2)
    else:
        print('No Circles Detected!')
    k += 1

# cv2.imshow('Gaze Koordinates',white_img)

src_Points = np.float32(center_list)
dst_Points = np.float32([[240, 135], [1680, 135], [1680, 945], [240, 945], [960, 540]])

H, mask = cv2.findHomography(src_Points, dst_Points) #, cv2.RANSAC, 5.0)            # find perspective transformation Matrix H

pts = np.float32(src_Points).reshape(-1, 5, 2)


if H is not None:
    dst_Array = cv2.perspectiveTransform(pts, H)
    # print dst_Array
else:
    print('No Homography Matrix created!')

error = np.matrix(np.subtract(dst_Points, dst_Array))            # difference between x,y coords of source points and calibrated points
print pts, dst_Array
dist = np.sqrt(np.square(error[:, 0]) + np.square(error[:, 1]))  # euclidian distance between calibration points and mapped points
# temp = np.sqrt(np.square(error))
print 'distance', dist

cv2.waitKey(0)
cv2.destroyAllWindows()
