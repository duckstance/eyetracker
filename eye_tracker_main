#!/usr/bin/env python
# -*- coding: utf-8 -*-
import cv2
import numpy as np
import argparse
import glob
import os
from scipy.spatial.distance import cdist
from scipy.spatial import distance
import matplotlib.pyplot as plt
import time
# import functions
import pupil_detection_optimal as pupil_detection
import rough_estimation
import evaluation,evaluation_angle,evaluation_corrected
import calibration
from scipy.optimize import fmin

start = time.clock()    # start timer

filelist_left = []
filelist_right = []
imglist_left = []
imglist_right = []
cimglist_left = []
cimglist_right = []
pupilcenter_list_left = []
pupilcenter_list_right = []
corrected_coords_left = []
corrected_coords_right = []
corrected_coords_x = []
corrected_coords_y = []
# Mat_centers = np.zeros((5, 3), np.float32)      # Zeilen, Spalten

img_resolution_factor = 1.0
pixelpitch_monitor = 0.058      # cm/px
pixelpitch_sensor = 0.00015875  # cm/px
distance_eye_monitor = 200.0    # cm
distance_eyes = 6.4             # cm
monitor_res_x = 1920.0            # px
monitor_res_y = 1080.0            # px

# Maya Kamera data
focal_lenght = 3.8              # cm
sensor_width = 0.549092588388   # cm
sensor_width_px = 3840.0          # px
sensor_height = 0.308864580969  # cm
sensor_height_px = 2160.0         # px
sensor_diagonal = 0.63          # cm

# r'../data/tests/3D/calibration/500cm/left'

# load left eye images
path_left = r'../data/tests/3D/calibration/200cm/left'
imglist_left = calibration.load_imgs(path_left)

# load right eye images
path_right = r'../data/tests/3D/calibration/200cm/right'
imglist_right = calibration.load_imgs(path_right)

number_imgs = len(imglist_left)

height, width = imglist_left[0].shape       # get image size
height /= img_resolution_factor
width /= img_resolution_factor

# calibration
norm_factor_left, norm_factor_right, Homography_left, Homography_right, distance_eyes, distance_eye_monitor = calibration.calibrate(img_resolution_factor)
distance_eyes = 6.4
distance_eye_monitor = 200.0 
# detect pupil center in left eye images
pupil_centered_left = calibration.detect_pupil_centers(imglist_left, img_resolution_factor)

# correct left pupil coordinates
transformed_points_left = calibration.correct_pupil_points(pupil_centered_left, norm_factor_left, Homography_left)

# detect pupil center in right eye images
pupil_centered_right = calibration.detect_pupil_centers(imglist_right, img_resolution_factor)

# correct right pupil coordinates
transformed_points_right = calibration.correct_pupil_points(pupil_centered_right, norm_factor_right, Homography_right)

## calculate distance
# distance = evaluation.distance_calc(transformed_points_left)

# pupil_error_left_x = np.ravel(transformed_points_left[:, 0]).reshape(number_imgs, 1)
# pupil_error_left_y = np.ravel(transformed_points_left[:, 1]).reshape(number_imgs, 1)
#
# transformed_points2_right = transformed_points_right[0]
# pupil_error_right_x = np.ravel(transformed_points2_right[:, 0]).reshape(number_imgs, 1)
# pupil_error_right_y = np.ravel(transformed_points2_right[:, 1]).reshape(number_imgs, 1)

# plot_x = pupil_error_x
# plot_y = pupil_error_y
# plot1_x = np.ravel(transformed_points2_left[:, 0]).reshape(number_imgs, 1)
# plot1_y = np.ravel(transformed_points2_left[:, 1]).reshape(number_imgs, 1)
# plot2_x = np.ravel(transformed_points2_right[:, 0]).reshape(number_imgs, 1)
# plot2_y = np.ravel(transformed_points2_right[:, 1]).reshape(number_imgs, 1)
# plt.figure(num=None, figsize=(6.5, 6), dpi=140, facecolor='w', edgecolor='k') #figsize=(7, 7),
# plt.grid(color='0.5')
# plt.axhline(0, color='k')
# plt.axvline(0, color='k')
#
# # plt.plot(plot_x,plot_y, 'kx')
# plt.plot(plot1_x, plot1_y, 'bx')
# plt.plot(plot2_x, plot2_y, 'rx')
# # plt.axis([-0.4, 0.4, -0.4, 0.4])
# plt.subplots_adjust(left=0.14, right=0.86)
# plt.xlabel('$\Delta x$ (Pixel)')
# plt.ylabel('$\Delta y$ (Pixel)')
#
# for i in range(1, number_imgs+1):
#     plt.annotate(i, xy=(plot1_x[i - 1], plot1_y[i - 1]), xytext = (-0.2, 0.2), textcoords = 'offset points', ha = 'right', va = 'bottom', color='0.4')
# # plt.savefig('foo.pdf', figsize=(7, 7), bbox_inches='tight')
# plt.show()


# initial guesses

# optimized_args = calibration.calibrate_3D(Homography_left, Homography_right, norm_factor_left, norm_factor_right, img_resolution_factor)
# distance_eyes = optimized_args[0]
# distance_eye_monitor = optimized_args[1]
# calculate fixation depth
for i in range(number_imgs):
    # monitor centered coordinates in cm
    x_left_cm = (transformed_points_left[i, 0] - monitor_res_x / 2) * pixelpitch_monitor
    x_right_cm = (transformed_points_right[i, 0] - monitor_res_x / 2) * pixelpitch_monitor
    y_left_cm = (transformed_points_left[i, 1] - monitor_res_y / 2) * pixelpitch_monitor
    y_right_cm = (transformed_points_right[i, 1] - monitor_res_y / 2) * pixelpitch_monitor

    if x_left_cm - x_right_cm + distance_eyes > 0:
        z_3D = distance_eyes * distance_eye_monitor / (x_left_cm - x_right_cm + distance_eyes)

    else:
        z_3D = np.inf

    x_3D = z_3D * (x_left_cm + x_right_cm) / (2 * distance_eye_monitor)

    y_3D = z_3D * (y_left_cm + y_right_cm) / (2 * distance_eye_monitor)

    print 'Image number:', i+1
    print 'Pixel Left Eye:\t\t', transformed_points_left[i, 0], 'Px\t', transformed_points_left[i, 1], 'Px'
    print 'Pixel Right Eye:\t', transformed_points_right[i, 0], 'Px\t', transformed_points_right[i, 1], 'Px'
    print 'x:', round(x_3D, 3), 'cm'
    print 'y:', round(y_3D, 3), 'cm'
    print 'z:', round(z_3D, 3), 'cm', '\n'


elapsed = (time.clock() - start)
# print 'elapsed time:', elapsed

cv2.waitKey(0)
cv2.destroyAllWindows()


